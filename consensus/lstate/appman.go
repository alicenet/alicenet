package lstate

import (
	"bytes"
	"errors"
	"log"

	"github.com/dgraph-io/badger/v2"

	aobjs "github.com/alicenet/alicenet/application/objs"
	"github.com/alicenet/alicenet/application/objs/uint256"
	"github.com/alicenet/alicenet/consensus/objs"
	"github.com/alicenet/alicenet/constants"
	"github.com/alicenet/alicenet/crypto"
	"github.com/alicenet/alicenet/errorz"
	"github.com/alicenet/alicenet/interfaces"
	"github.com/alicenet/alicenet/utils"
)

// AddPendingTx ...
func (ce *Engine) AddPendingTx(txn *badger.Txn, d []interfaces.Transaction) error {
	os, err := ce.database.GetOwnState(txn)
	if err != nil {
		utils.DebugTrace(ce.logger, err)
		return err
	}
	err = ce.appHandler.PendingTxAdd(txn, os.SyncToBH.BClaims.ChainID, os.SyncToBH.BClaims.Height+1, d)
	if err != nil {
		e := errorz.ErrInvalid{}.New("already  mined")
		if errors.As(err, &e) {
			utils.DebugTrace(ce.logger, err)
			return err
		}
	}
	return nil
}

// todo: **START** DELETE THIS DEBUG CODE

func makeTransfer(sender aobjs.Signer, receiver aobjs.Signer, transferAmount uint64, v *aobjs.TXOut) (*aobjs.Tx, error) {
	txIn, err := v.MakeTxIn()
	if err != nil {
		return nil, err
	}
	txInHash, err := txIn.PreHash()
	if err != nil {
		return nil, err
	}
	log.Printf("TXIn PreHash: %x\n", txInHash)
	value, err := v.Value()
	vuint64, err := value.ToUint64()
	returnedAmount := vuint64 - transferAmount
	value = &uint256.Uint256{}
	_, _ = value.FromUint64(returnedAmount)
	value2 := &uint256.Uint256{}
	_, _ = value2.FromUint64(transferAmount)

	if err != nil {
		return nil, err
	}
	chainID, err := txIn.ChainID()
	if err != nil {
		return nil, err
	}
	receiverPubkey, err := receiver.Pubkey()
	if err != nil {
		return nil, err
	}

	senderPubkey, err := sender.Pubkey()
	if err != nil {
		return nil, err
	}

	tx := &aobjs.Tx{}
	tx.Vin = []*aobjs.TXIn{txIn}
	newValueStoreSender := &aobjs.ValueStore{
		VSPreImage: &aobjs.VSPreImage{
			ChainID:  chainID,
			Value:    value,
			Owner:    &aobjs.ValueStoreOwner{SVA: aobjs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(senderPubkey)},
			Fee:      new(uint256.Uint256).SetZero(),
			TXOutIdx: 0,
		},
		TxHash: make([]byte, 32),
	}

	// the new utxo that will be generated by this transaction
	newValueStoreReceiver := &aobjs.ValueStore{
		VSPreImage: &aobjs.VSPreImage{
			ChainID:  chainID,
			Value:    value2,
			Owner:    &aobjs.ValueStoreOwner{SVA: aobjs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(receiverPubkey)},
			Fee:      new(uint256.Uint256).SetZero(),
			TXOutIdx: 1,
		},
		TxHash: make([]byte, 32),
	}
	newUTXOSender := &aobjs.TXOut{}
	err = newUTXOSender.NewValueStore(newValueStoreSender)
	if err != nil {
		return nil, err
	}
	txOutPreHash, err := newUTXOSender.PreHash()
	if err != nil {
		return nil, err
	}
	log.Printf("TXOut PreHash: %x\n", txOutPreHash)
	newUTXOReceiver := &aobjs.TXOut{}
	err = newUTXOReceiver.NewValueStore(newValueStoreReceiver)
	if err != nil {
		return nil, err
	}
	tx.Fee = new(uint256.Uint256).SetZero()
	tx.Vout = append(tx.Vout, newUTXOSender, newUTXOReceiver)
	err = tx.SetTxHash() // <- compute the root from the TxHash smt
	if err != nil {
		return nil, err
	}

	err = newValueStoreSender.Sign(tx.Vin[0], sender)
	if err != nil {
		return nil, err
	}

	return tx, nil
}
func createNonExistentUTXO(chainID uint32, value *uint256.Uint256, senderPubkey []byte, txHash []byte, txOutIdx uint32) (*aobjs.TXOut, error) {
	newValueStoreSender := &aobjs.ValueStore{
		VSPreImage: &aobjs.VSPreImage{
			ChainID:  chainID,
			Value:    value,
			Owner:    &aobjs.ValueStoreOwner{SVA: aobjs.ValueStoreSVA, CurveSpec: constants.CurveSecp256k1, Account: crypto.GetAccount(senderPubkey)},
			Fee:      new(uint256.Uint256).SetZero(),
			TXOutIdx: txOutIdx,
		},
		TxHash: txHash,
	}

	newUTXO := &aobjs.TXOut{}
	err := newUTXO.NewValueStore(newValueStoreSender)
	if err != nil {
		return nil, err
	}
	return newUTXO, nil
}

func createBadTx(sender aobjs.Signer, receiver aobjs.Signer, transferAmount uint64) (*aobjs.Tx, error) {
	pubKey, err := sender.Pubkey()
	if err != nil {
		return nil, err
	}
	value := &uint256.Uint256{}
	_, _ = value.FromUint64(transferAmount)
	nonExistingUTXO, err := createNonExistentUTXO(1337, value, pubKey, crypto.Hasher([]byte("lol")), 0)
	if err != nil {
		return nil, err
	}

	tx, err := makeTransfer(sender, receiver, 1, nonExistingUTXO)
	if err != nil {
		return nil, err
	}

	return tx, nil
}

// todo: **END** DELETE THIS DEBUG CODE

func (ce *Engine) getValidValue(txn *badger.Txn, rs *RoundStates) ([][]byte, []byte, []byte, []byte, error) {
	chainID := rs.OwnState.SyncToBH.BClaims.ChainID
	txs, stateRoot, err := ce.appHandler.GetValidProposal(txn, chainID, rs.OwnState.SyncToBH.BClaims.Height+1, ce.storage.GetMaxProposalSize())
	if err != nil {
		utils.DebugTrace(ce.logger, err)
		return nil, nil, nil, nil, err
	}

	// todo: **START** DELETE THIS DEBUG CODE
	// todo: append bad transaction here
	badHeight := 10
	if int(rs.height) > badHeight && bytes.Equal(rs.ValidatorSet.Validators[0].VAddr, rs.GetCurrentProposal().Proposer) {
		var badTx interfaces.Transaction
		badTx, err = createBadTx(ce.secpSigner, ce.secpSigner, 1)
		if err != nil {
			utils.DebugTrace(ce.logger, err)
			return nil, nil, nil, nil, err
		}
		// todo: append bad Tx to list of Txs
		txs = append(txs, badTx)
	}
	// todo: **END** DELETE THIS DEBUG CODE

	if err := ce.dm.AddTxs(txn, rs.OwnState.SyncToBH.BClaims.Height+1, txs); err != nil {
		utils.DebugTrace(ce.logger, err)
		return nil, nil, nil, nil, err
	}
	txHashes := make([][]byte, len(txs))
	for i := 0; i < len(txs); i++ {
		tx := txs[i]
		txHash, err := tx.TxHash()
		if err != nil {
			return nil, nil, nil, nil, err
		}
		txHashes[i] = txHash
	}
	txRootHash, err := objs.MakeTxRoot(txHashes)
	if err != nil {
		utils.DebugTrace(ce.logger, err)
		return nil, nil, nil, nil, err
	}
	headerRoot, err := ce.database.GetHeaderTrieRoot(txn, rs.OwnState.SyncToBH.BClaims.Height)
	if err != nil {
		if err != badger.ErrKeyNotFound {
			utils.DebugTrace(ce.logger, err)
			return nil, nil, nil, nil, err
		}
		headerRoot = make([]byte, constants.HashLen)
	}
	return txHashes, txRootHash, stateRoot, headerRoot, nil
}

func (ce *Engine) isValid(txn *badger.Txn, rs *RoundStates, chainID uint32, stateHash, headerRoot []byte, txs []interfaces.Transaction) (bool, error) {
	goodHeaderRoot, err := ce.database.GetHeaderTrieRoot(txn, rs.OwnState.SyncToBH.BClaims.Height)
	if err != nil {
		utils.DebugTrace(ce.logger, err)
		return false, err
	}
	if !bytes.Equal(goodHeaderRoot, headerRoot) {
		utils.DebugTrace(ce.logger, err)
		return false, nil
	}
	ok, err := ce.appHandler.IsValid(txn, chainID, rs.OwnState.SyncToBH.BClaims.Height+1, stateHash, txs)
	if err != nil {
		e := errorz.ErrInvalid{}.New("")
		if errors.As(err, &e) {
			return false, nil
		}
		utils.DebugTrace(ce.logger, err)
		return false, err
	}
	if !ok {
		return false, errorz.ErrInvalid{}.New("is valid returned not ok")
	}
	if err := ce.dm.AddTxs(txn, rs.OwnState.SyncToBH.BClaims.Height+1, txs); err != nil {
		utils.DebugTrace(ce.logger, err)
		return false, err
	}
	return true, nil
}

func (ce *Engine) applyState(txn *badger.Txn, rs *RoundStates, chainID uint32, txHashes [][]byte) error {
	txs, missing, err := ce.dm.GetTxs(txn, rs.OwnState.SyncToBH.BClaims.Height+1, rs.round, txHashes)
	if err != nil {
		return err
	}
	if len(missing) > 0 {
		return errorz.ErrMissingTransactions
	}
	if err := ce.dm.AddTxs(txn, rs.OwnState.SyncToBH.BClaims.Height+1, txs); err != nil {
		utils.DebugTrace(ce.logger, err)
		return err
	}
	_, err = ce.appHandler.ApplyState(txn, chainID, rs.OwnState.SyncToBH.BClaims.Height+1, txs)
	if err != nil {
		utils.DebugTrace(ce.logger, err)
		return err
	}
	return nil
}
