import fs from "fs";
import { task } from "hardhat/config";
import { DeploymentConfigWrapper } from "../lib/deployment/interfaces";
import {
  checkUserDirPath,
  generateDeployConfigTemplate,
  getAllContracts,
  getSortedDeployList,
  readDeploymentConfig,
} from "../lib/deployment/utils";

task("generate-immutable-auth-contract", "Generate contracts")
  .addOptionalParam("configFile", "deployment config json file", undefined)
  .addOptionalParam(
    "output",
    "path to save the generated `ImmutableAuth.sol`",
    undefined
  )
  .setAction(async ({ configFile, output }, hre) => {
    const contractNameSaltMap = [];
    let contracts: DeploymentConfigWrapper;

    if (output === undefined) {
      output = "contracts/utils/auth/";
    }
    await checkUserDirPath(output);

    if (configFile === undefined) {
      const allContracts = await getAllContracts(hre.artifacts);
      const deploymentList = await getSortedDeployList(
        allContracts,
        hre.artifacts,
        hre.ethers
      );
      contracts = await generateDeployConfigTemplate(
        deploymentList,
        hre.artifacts,
        hre.ethers
      );
    } else {
      contracts = readDeploymentConfig(configFile);
    }
    for (const key in contracts) {
      const contract = contracts[key];
      const contractName = contract.name;
      const salt = contract.salt;
      salt && contractNameSaltMap.push([contractName, salt]);
    }

    fs.writeFileSync(
      output + "ImmutableFactory.sol",
      basicHeader + templateImmutableFactory
    );

    fs.writeFileSync(
      output + "ImmutableALCA.sol",
      basicHeader +
        alicenetImmutableImport +
        alicenetInterfaceImport +
        templateALCA(hre.ethers.utils.formatBytes32String("ALCA"))
    );

    fs.writeFileSync(
      output + "ImmutableALCB.sol",
      basicHeader +
        alicenetImmutableImport +
        alicenetInterfaceImport +
        templateALCB(hre.ethers.utils.formatBytes32String("ALCB"))
    );

    for (const contractNameSalt of contractNameSaltMap) {
      let immutableContract = basicHeader + alicenetImmutableImport;
      const name = contractNameSalt[0];
      const salt = contractNameSalt[1];
      const c = new Contract(name, salt);
      immutableContract += templateContract(c);
      fs.writeFileSync(output + `Immutable${name}.sol`, immutableContract);
    }
  });

export class Contract {
  name: string;
  salt: string;

  constructor(name: string, salt: string) {
    this.name = name;
    this.salt = salt;
  }
}

const basicHeader = `// This file is auto-generated by hardhat generate-immutable-auth-contract task. DO NOT EDIT.
// SPDX-License-Identifier: MIT-open-group
pragma solidity ^0.8.16;

import "contracts/utils/DeterministicAddress.sol";`;

const alicenetInterfaceImport = `
import "contracts/interfaces/IAliceNetFactory.sol";`;

const alicenetImmutableImport = `
import "contracts/utils/auth/ImmutableFactory.sol";`;

const templateImmutableFactory = `

abstract contract ImmutableFactory is DeterministicAddress {
    address private immutable _factory;
    error OnlyFactory(address sender, address expected);

    modifier onlyFactory() {
      if (msg.sender != _factory) {
        revert OnlyFactory(msg.sender, _factory);
      }
      _;
  }

    constructor(address factory_) {
        _factory = factory_;
    }

    function _factoryAddress() internal view returns (address) {
        return _factory;
    }

}
`;

function templateALCA(salt: string): string {
  return `

abstract contract ImmutableALCA is ImmutableFactory {
    address private immutable _alca;
    error OnlyALCA(address sender, address expected);

    modifier onlyALCA() {
        if (msg.sender != _alca) {
            revert OnlyALCA(msg.sender, _alca);
        }
        _;
    }

    constructor() {
        _alca = IAliceNetFactory(_factoryAddress()).lookup(_saltForALCA());
    }

    function _alcaAddress() internal view returns (address) {
        return _alca;
    }

    function _saltForALCA() internal pure returns (bytes32) {
        return ${salt};
    }
}`;
}

function templateALCB(salt: string): string {
  return `

abstract contract ImmutableALCB is ImmutableFactory {
    address private immutable _alcb;
    error OnlyALCB(address sender, address expected);

    modifier onlyALCB() {
        if (msg.sender != _alcb) {
            revert OnlyALCB(msg.sender, _alcb);
        }
        _;
    }

    constructor() {
        _alcb = IAliceNetFactory(_factoryAddress()).lookup(_saltForALCB());
    }

    function _alcbAddress() internal view returns (address) {
        return _alcb;
    }

    function _saltForALCB() internal pure returns (bytes32) {
        return ${salt};
    }
}
`;
}

function templateContract(contract: Contract): string {
  let mixedContractName: string;
  if (contract.name.startsWith("ETHDKG")) {
    mixedContractName = "ethdkg" + contract.name.slice(6);
  } else if (contract.name.startsWith("ALCA")) {
    mixedContractName = "alca" + contract.name.slice(4);
  } else if (contract.name.startsWith("ALCB")) {
    mixedContractName = "alcb" + contract.name.slice(4);
  } else {
    mixedContractName =
      contract.name.charAt(0).toLowerCase() + contract.name.slice(1);
  }

  return `

abstract contract Immutable${contract.name} is ImmutableFactory {

    address private immutable _${mixedContractName};
    error Only${contract.name}(address sender, address expected);

    modifier only${contract.name}() {
        if (msg.sender != _${mixedContractName}) {
          revert Only${contract.name}(msg.sender, _${mixedContractName});
        }
        _;
    }

    constructor() {
        _${mixedContractName} = getMetamorphicContractAddress(${contract.salt}, _factoryAddress());
    }

    function _${mixedContractName}Address() internal view returns(address) {
        return _${mixedContractName};
    }

    function _saltFor${contract.name}() internal pure returns(bytes32) {
        return ${contract.salt};
    }
}
`;
}
