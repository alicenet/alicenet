import fs from "fs";
import { task } from "hardhat/config";
import { DeploymentConfigWrapper } from "../lib/deployment/interfaces";
import {
  checkUserDirPath,
  generateDeployConfigTemplate,
  getAllContracts,
  getSortedDeployList,
  readDeploymentConfig,
} from "../lib/deployment/utils";

task("generate-immutable-auth-contract", "Generate contracts")
  .addOptionalParam("configFile", "deployment config json file", undefined)
  .addOptionalParam(
    "output",
    "path to save the generated `ImmutableAuth.sol`",
    undefined
  )
  .setAction(async ({ configFile, output }, hre) => {
    const contractNameSaltMap = [];
    let contracts: DeploymentConfigWrapper;

    if (output === undefined) {
      output = "contracts/utils/auth/";
    }
    await checkUserDirPath(output);

    if (configFile === undefined) {
      const allContracts = await getAllContracts(hre.artifacts);
      const deploymentList = await getSortedDeployList(
        allContracts,
        hre.artifacts,
        hre.ethers
      );
      contracts = await generateDeployConfigTemplate(
        deploymentList,
        hre.artifacts,
        hre.ethers
      );
    } else {
      contracts = readDeploymentConfig(configFile);
    }
    for (const key in contracts) {
      const contract = contracts[key];
      const contractName = contract.name;
      const salt = contract.salt;
      contractName !== "AliceNetFactory" &&
        contractNameSaltMap.push([contractName, salt]);
    }

    fs.writeFileSync(
      output + "ImmutableFactory.sol",
      basicHeader + templateImmutableFactory
    );

    fs.writeFileSync(
      output + "ImmutableAToken.sol",
      basicHeader +
        alicenetImmutableImport +
        alicenetInterfaceImport +
        immutableAToken
    );

    fs.writeFileSync(
      output + "ImmutableBToken.sol",
      basicHeader +
        alicenetImmutableImport +
        alicenetInterfaceImport +
        immutableBToken
    );

    for (const contractNameSalt of contractNameSaltMap) {
      let immutableContract = basicHeader + alicenetImmutableImport;
      const name = contractNameSalt[0];
      const salt = contractNameSalt[1];
      const c = new Contract(name, salt);
      immutableContract += templateContract(c);
      fs.writeFileSync(output + `Immutable${name}.sol`, immutableContract);
    }
  });

export class Contract {
  name: string;
  salt: string;

  constructor(name: string, salt: string) {
    this.name = name;
    this.salt = salt;
  }
}

const basicHeader = `// This file is auto-generated by hardhat generate-immutable-auth-contract task. DO NOT EDIT.
// SPDX-License-Identifier: MIT-open-group
pragma solidity ^0.8.16;

import "contracts/utils/DeterministicAddress.sol";`;

const alicenetInterfaceImport = `
import "contracts/interfaces/IAliceNetFactory.sol";`;

const alicenetImmutableImport = `
import "contracts/utils/auth/ImmutableFactory.sol";`;

const templateImmutableFactory = `

abstract contract ImmutableFactory is DeterministicAddress {
    address private immutable _factory;
    error OnlyFactory(address sender, address expected);

    modifier onlyFactory() {
      if (msg.sender != _factory) {
        revert OnlyFactory(msg.sender, _factory);
      }
      _;
  }

    constructor(address factory_) {
        _factory = factory_;
    }

    function _factoryAddress() internal view returns (address) {
        return _factory;
    }

}
`;

const immutableAToken = `

abstract contract ImmutableAToken is ImmutableFactory {
    address private immutable _aToken;
    error OnlyAToken(address sender, address expected);

    modifier onlyAToken() {
        if (msg.sender != _aToken) {
            revert OnlyAToken(msg.sender, _aToken);
        }
        _;
    }

    constructor() {
        _aToken = IAliceNetFactory(_factoryAddress()).lookup(_saltForAToken());
    }

    function _aTokenAddress() internal view returns (address) {
        return _aToken;
    }

    function _saltForAToken() internal pure returns (bytes32) {
        return 0x41546f6b656e0000000000000000000000000000000000000000000000000000;
    }
}`;

const immutableBToken = `

abstract contract ImmutableBToken is ImmutableFactory {
    address private immutable _bToken;
    error OnlyBToken(address sender, address expected);

    modifier onlyBToken() {
        if (msg.sender != _bToken) {
            revert OnlyBToken(msg.sender, _bToken);
        }
        _;
    }

    constructor() {
        _bToken = IAliceNetFactory(_factoryAddress()).lookup(_saltForBToken());
    }

    function _bTokenAddress() internal view returns (address) {
        return _bToken;
    }

    function _saltForBToken() internal pure returns (bytes32) {
        return 0x42546f6b656e0000000000000000000000000000000000000000000000000000;
    }
}
`;

function templateContract(contract: Contract): string {
  let mixedContractName: string;
  if (contract.name.startsWith("ETHDKG")) {
    mixedContractName = "ethdkg" + contract.name.slice(6);
  } else {
    mixedContractName =
      contract.name.charAt(0).toLowerCase() + contract.name.slice(1);
  }

  return `

abstract contract Immutable${contract.name} is ImmutableFactory {

    address private immutable _${mixedContractName};
    error Only${contract.name}(address sender, address expected);

    modifier only${contract.name}() {
        if (msg.sender != _${mixedContractName}) {
          revert Only${contract.name}(msg.sender, _${mixedContractName});
        }
        _;
    }

    constructor() {
        _${mixedContractName} = getMetamorphicContractAddress(${contract.salt}, _factoryAddress());
    }

    function _${mixedContractName}Address() internal view returns(address) {
        return _${mixedContractName};
    }

    function _saltFor${contract.name}() internal pure returns(bytes32) {
        return ${contract.salt};
    }
}
    `;
}
